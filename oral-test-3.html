<!DOCTYPE html>
<html lang="zh-CN" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" content="notranslate">
    <title>Oral Test 3 - Dialogue Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/common.css">
    <script src="js/utils.js"></script>
    <script src="js/command-palette.js"></script>
    <script src="js/pinyin-utils.js"></script>
    <script type="module">
        import { EdgeTTS } from 'https://cdn.jsdelivr.net/npm/edge-tts-universal/dist/browser.js';

        // Chinese voices: zh-CN-XiaoxiaoNeural (female), zh-CN-YunxiNeural (male)
        window.edgeTTS = async function(text, voice = 'zh-CN-XiaoxiaoNeural') {
            try {
                const cleanText = text.replace(/\*[^*]+\*/g, '').replace(/„Äà[^„Äâ]+„Äâ/g, '');
                const tts = new EdgeTTS(cleanText, voice);
                const result = await tts.synthesize();
                const audio = new Audio(URL.createObjectURL(new Blob([result.audio], { type: 'audio/mp3' })));
                audio.play();
            } catch (err) {
                console.error('Edge TTS error:', err);
                // Fallback to browser TTS
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.85;
                speechSynthesis.speak(utterance);
            }
        };
    </script>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">
    <a href="home.html" class="fixed top-4 left-4 bg-white hover:bg-gray-100 text-gray-700 px-3 py-2 rounded-lg shadow border border-gray-200 transition text-sm">‚Üê Home</a>

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8 mt-16 md:mt-0">
        <h1 class="text-3xl font-bold text-center mb-2 text-gray-800">Oral Test 3</h1>
        <p class="text-center text-gray-600 mb-1">CHIN 111 - Dec 4, 11:30 AM</p>
        <p class="text-center text-gray-500 text-sm mb-6">Sam, Daniel, Jeremy - 17 sentences, 15 patterns</p>

        <!-- Mode Selector -->
        <div class="flex flex-wrap gap-2 justify-center mb-6">
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition" data-mode="study">Study All</button>
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition active" data-mode="english-to-chinese">English ‚Üí Chinese</button>
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition" data-mode="role-jeremy">Practice Jeremy</button>
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition" data-mode="fill-blank">Fill Pattern</button>
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition" data-mode="flow">Flow Practice</button>
            <button class="mode-btn px-4 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100 transition" data-mode="translate">Translate</button>
        </div>

        <!-- Study Mode -->
        <div id="studyMode" class="hidden">
            <div id="dialogueList" class="space-y-3"></div>
        </div>

        <!-- Practice Mode -->
        <div id="practiceMode" class="hidden">
            <!-- Context (preceding lines) -->
            <div id="contextDisplay" class="hidden mb-4 p-4 bg-amber-50 rounded-lg border border-amber-200">
                <div class="text-xs text-amber-600 mb-2 font-semibold">Context (what comes before):</div>
                <div id="contextLines" class="space-y-2 text-sm"></div>
            </div>

            <!-- Line Number -->
            <div id="lineNumber" class="text-center text-sm text-gray-500 mb-2"></div>

            <!-- Speaker -->
            <div id="speaker" class="text-center text-lg font-bold mb-4"></div>

            <!-- Question Display -->
            <div id="questionDisplay" class="text-center text-2xl mb-6 p-6 bg-gray-50 rounded-lg min-h-[100px] flex items-center justify-center"></div>

            <!-- Pattern Hint -->
            <div id="patternHint" class="text-center text-sm text-purple-600 mb-4"></div>

            <!-- Audio Button -->
            <div class="text-center mb-4 flex flex-wrap gap-2 justify-center">
                <button id="playAudioBtn" class="bg-cyan-500 hover:bg-cyan-600 text-white px-6 py-3 rounded-lg transition">
                    üîä Play Audio
                </button>
                <button id="recordBtn" class="bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg transition">
                    üé§ Record
                </button>
                <button id="showAnswerBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg transition">
                    üëÅ Show Answer
                </button>
            </div>

            <!-- Transcription Display -->
            <div id="transcriptionDisplay" class="hidden text-center p-4 bg-blue-50 rounded-lg mb-4">
                <div class="text-sm text-gray-500 mb-1">Your speech:</div>
                <div id="transcriptionText" class="text-xl mb-2"></div>
                <div id="transcriptionFeedback" class="text-sm"></div>
            </div>

            <!-- Answer Display -->
            <div id="answerDisplay" class="hidden text-center p-4 bg-green-50 rounded-lg mb-4">
                <div id="answerChinese" class="text-2xl mb-2"></div>
                <div id="answerPinyin" class="text-gray-600"></div>
            </div>

            <!-- Navigation -->
            <div class="flex justify-between items-center mt-6">
                <button id="prevBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg transition">‚Üê Prev</button>
                <span id="progress" class="text-gray-600"></span>
                <button id="nextBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition">Next ‚Üí</button>
            </div>
        </div>

        <!-- Fill Pattern Mode -->
        <div id="fillMode" class="hidden">
            <div id="fillLineNumber" class="text-center text-sm text-gray-500 mb-2"></div>
            <div id="fillSpeaker" class="text-center text-lg font-bold mb-4"></div>
            <div id="fillQuestion" class="text-center text-2xl mb-4 p-6 bg-gray-50 rounded-lg"></div>
            <div id="fillEnglish" class="text-center text-gray-600 mb-4"></div>

            <input type="text" id="fillInput" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none text-lg text-center mb-4" placeholder="Type the pattern word(s)...">

            <div class="flex gap-2 justify-center mb-4">
                <button id="fillCheckBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg transition">Check</button>
                <button id="fillAudioBtn" class="bg-cyan-500 hover:bg-cyan-600 text-white px-6 py-3 rounded-lg transition">üîä</button>
            </div>

            <div id="fillFeedback" class="text-center text-xl font-semibold mb-4 min-h-[28px]"></div>

            <div class="flex justify-between items-center">
                <button id="fillPrevBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg transition">‚Üê Prev</button>
                <span id="fillProgress" class="text-gray-600"></span>
                <button id="fillNextBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition">Next ‚Üí</button>
            </div>
        </div>

        <!-- Flow Mode -->
        <div id="flowMode" class="hidden">
            <div class="text-center mb-6">
                <div class="text-sm text-gray-500 mb-2">Press <kbd class="px-2 py-1 bg-gray-200 rounded">Space</kbd> when it's your turn (within 2 seconds)</div>
                <button id="flowStartBtn" class="bg-green-500 hover:bg-green-600 text-white px-8 py-4 rounded-lg text-xl transition">‚ñ∂ Start Flow</button>
            </div>

            <!-- Current speaker display -->
            <div id="flowDisplay" class="hidden">
                <div id="flowSpeaker" class="text-center text-2xl font-bold mb-4"></div>
                <div id="flowLine" class="text-center text-3xl mb-6 p-8 bg-gray-50 rounded-lg min-h-[120px] flex items-center justify-center"></div>
                <div id="flowStatus" class="text-center text-xl font-semibold mb-4 min-h-[28px]"></div>
                <div id="flowTimer" class="hidden text-center">
                    <div class="inline-block w-48 h-2 bg-gray-200 rounded-full overflow-hidden">
                        <div id="flowTimerBar" class="h-full bg-red-500 transition-all duration-100"></div>
                    </div>
                    <div class="text-sm text-gray-500 mt-1">Your turn! Press Space!</div>
                </div>
            </div>

            <!-- Score -->
            <div id="flowScore" class="hidden text-center mt-6 p-4 bg-gray-100 rounded-lg">
                <span class="text-lg">Score: <span id="flowHits" class="font-bold text-green-600">0</span> / <span id="flowTotal" class="font-bold">0</span></span>
                <span class="ml-4 text-gray-500">Missed: <span id="flowMisses" class="text-red-500">0</span></span>
            </div>
        </div>

        <!-- Translate Mode -->
        <div id="translateMode" class="hidden">
            <div id="translateLineNumber" class="text-center text-sm text-gray-500 mb-2"></div>
            <div id="translateSpeaker" class="text-center text-lg font-bold mb-4"></div>

            <!-- Chinese prompt -->
            <div id="translatePrompt" class="text-center text-3xl mb-6 p-6 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100" title="Click to play audio"></div>

            <!-- Translation input -->
            <textarea id="translateInput" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none text-lg mb-4" rows="2" placeholder="Type your English translation..."></textarea>

            <div class="flex gap-2 justify-center mb-4">
                <button id="translateCheckBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg transition">Check Translation</button>
                <button id="translateAudioBtn" class="bg-cyan-500 hover:bg-cyan-600 text-white px-6 py-3 rounded-lg transition">üîä</button>
            </div>

            <!-- LLM Feedback -->
            <div id="translateFeedback" class="hidden p-4 rounded-lg mb-4">
                <div id="translateResult" class="mb-2"></div>
                <div id="translateExplanation" class="text-sm text-gray-600"></div>
                <div id="translateReference" class="text-sm text-gray-500 mt-2 pt-2 border-t"></div>
            </div>

            <!-- Navigation -->
            <div class="flex justify-between items-center">
                <button id="translatePrevBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg transition">‚Üê Prev</button>
                <span id="translateProgress" class="text-gray-600"></span>
                <button id="translateNextBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition">Next ‚Üí</button>
            </div>
        </div>

        <!-- Pattern Reference -->
        <div class="mt-8 bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg">
            <h3 class="font-bold mb-2">üìö Grammar Patterns Used (15 total)</h3>
            <div class="text-xs grid grid-cols-2 gap-1 text-gray-700">
                <div><span class="font-semibold">1.</span> A ÊØî B adj. ÂæóÂ§ö/Â§ö‰∫Ü</div>
                <div><span class="font-semibold">3.</span> Âà∞Â∫ï</div>
                <div><span class="font-semibold">5.</span> V Ëµ∑Êù•</div>
                <div><span class="font-semibold">13.</span> Êâç...Âë¢ (emphasis)</div>
                <div><span class="font-semibold">14.</span> Âè™Ë¶Å...Â∞±...</div>
                <div><span class="font-semibold">16.</span> ÂÖ∂ÂÆû...Âπ∂‰∏ç...</div>
                <div><span class="font-semibold">19.</span> Ëøû...ÈÉΩ...</div>
                <div><span class="font-semibold">20.</span> A ‰πüÂ•ΩÔºåB ‰πüÂ•ΩÔºåÈÉΩ...</div>
                <div><span class="font-semibold">22.</span> ÈöæÈÅì...ÂêóÔºü</div>
                <div><span class="font-semibold">23.</span> Ë¶ÅÊòØ...ÊÄé‰πàÂäûÔºü</div>
                <div><span class="font-semibold">25.</span> ‰∏çÊÉ≥ÂÜç...‰∫Ü</div>
                <div><span class="font-semibold">26.</span> adj. ÊòØ adj.ÔºåÂèØÊòØ...</div>
                <div><span class="font-semibold">28.</span> adj. ÂæóÂæà</div>
                <div><span class="font-semibold">29.</span> Time Ê≤° V ‰∫Ü</div>
                <div><span class="font-semibold">30.</span> ÊúÄÂ•Ω + V</div>
            </div>
        </div>
    </div>

    <script>
        // Dialogue data
        const dialogue = [
            {
                line: 1,
                speaker: 'Sam',
                chinese: 'Êàë‰∏çÊÉ≥ÂÜçÂú®È£üÂ†ÇÂêÉÈ•≠‰∫ÜÔºå‰Ω†‰ª¨Âà∞Â∫ïÊÉ≥ÂêÉ‰ªÄ‰πàÂë¢Ôºü',
                pinyin: 'W«í b√π xi«éng z√†i z√†i sh√≠t√°ng chƒ´f√†n le, n«êmen d√†od«ê xi«éng chƒ´ sh√©nme ne?',
                english: "I don't want to eat at the cafeteria anymore, what do you guys actually want to eat?",
                patterns: ['‰∏çÊÉ≥ÂÜç...‰∫Ü', 'Âà∞Â∫ï'],
                patternWords: '‰∏çÊÉ≥ÂÜç/‰∫Ü, Âà∞Â∫ï'
            },
            {
                line: 2,
                speaker: 'Daniel',
                chinese: 'ÊàëËßâÂæóÂú®ÂÆ∂ÂÅöÈ•≠ÊØîÁÇπÂ§ñÂçñÂ•ΩÂ§ö‰∫Ü„ÄÇ',
                pinyin: 'W«í ju√©de z√†i jiƒÅ zu√≤f√†n b«ê di«én w√†im√†i h«éo du≈ç le.',
                english: 'I think cooking at home is way better than ordering takeout.',
                patterns: ['A ÊØî B adj. Â§ö‰∫Ü'],
                patternWords: 'ÊØî/Â•ΩÂ§ö‰∫Ü'
            },
            {
                line: 3,
                speaker: 'Jeremy',
                chinese: 'ÈöæÈÅì‰Ω†ÊÉ≥ÂÅöÈ•≠ÂêóÔºü',
                pinyin: 'N√°nd√†o n«ê xi«éng zu√≤f√†n ma?',
                english: "Don't tell me you actually want to cook?",
                patterns: ['ÈöæÈÅì...ÂêóÔºü'],
                patternWords: 'ÈöæÈÅì/Âêó'
            },
            {
                line: 4,
                speaker: 'Sam',
                chinese: 'Âè™Ë¶ÅÊàëÂÅöÈ•≠Â∞±Ë°å„ÄÇ',
                pinyin: 'Zh«êy√†o w«í zu√≤f√†n ji√π x√≠ng.',
                english: "As long as I'm the one cooking, it'll be fine.",
                patterns: ['Âè™Ë¶Å...Â∞±...'],
                patternWords: 'Âè™Ë¶Å/Â∞±'
            },
            {
                line: 5,
                speaker: 'Daniel',
                chinese: 'ÊàëÊâç‰∏ç‰ø°Âë¢ÔºåËÆ©ÊàëÂÅöÂêß„ÄÇ',
                pinyin: 'W«í c√°i b√π x√¨n ne, r√†ng w«í zu√≤ ba.',
                english: "I don't believe you at all, let me cook instead.",
                patterns: ['Êâç...Âë¢'],
                patternWords: 'Êâç/Âë¢'
            },
            {
                line: 6,
                speaker: 'Sam',
                chinese: 'ÊàëÊâç‰∏çÊÉ≥ÂêÉ‰Ω†‰ª¨ÂÅöÁöÑÈ•≠Âë¢„ÄÇ',
                pinyin: 'W«í c√°i b√π xi«éng chƒ´ n«êmen zu√≤ de f√†n ne.',
                english: "I don't want to eat the food you guys make at all.",
                patterns: ['Êâç...Âë¢'],
                patternWords: 'Êâç/Âë¢'
            },
            {
                line: 7,
                speaker: 'Jeremy',
                chinese: 'Ë¶ÅÊòØ‰Ω†‰ª¨ÂÅöÁöÑ‰∏çÂ•ΩÂêÉÔºåÈÇ£ÊÄé‰πàÂäûÂë¢Ôºü',
                pinyin: 'Y√†oshi n«êmen zu√≤ de b√π h«éochƒ´, n√† zƒõnme b√†n ne?',
                english: "If what you guys make doesn't taste good, then what are we going to do?",
                patterns: ['Ë¶ÅÊòØ...ÊÄé‰πàÂäûÔºü'],
                patternWords: 'Ë¶ÅÊòØ/ÊÄé‰πàÂäû'
            },
            {
                line: 8,
                speaker: 'Sam',
                chinese: 'ÊîæÂøÉÂêßÔºÅ',
                pinyin: 'F√†ngxƒ´n ba!',
                english: "Don't worry!",
                patterns: [],
                patternWords: ''
            },
            {
                line: '‚è∞',
                speaker: '',
                chinese: '„Äàtime lapse cooking„Äâ',
                pinyin: '',
                english: '„Äàtime lapse cooking„Äâ',
                patterns: [],
                patternWords: '',
                isStageDirection: true
            },
            {
                line: 9,
                speaker: 'Sam',
                chinese: 'Â•ΩÔºåÈ•≠ÂÅöÂÆå‰∫ÜÔºå‰Ω†‰ª¨ÂêÉÂêß„ÄÇ',
                pinyin: 'H«éo, f√†n zu√≤ w√°n le, n«êmen chƒ´ ba.',
                english: "Alright, the food is ready, go ahead and eat.",
                patterns: [],
                patternWords: ''
            },
            {
                line: 10,
                speaker: 'Daniel',
                chinese: 'ÈóªËµ∑Êù•ÂæàÈ¶ôÔºåÂèØÊòØÂêÉËµ∑Êù•ÈöæÂêÉÂæóÂæà„ÄÇ',
                pinyin: 'W√©n q«êl√°i hƒõn xiƒÅng, kƒõsh√¨ chƒ´ q«êl√°i n√°nchƒ´ de hƒõn.',
                english: 'It smells really good, but it tastes really bad.',
                patterns: ['V Ëµ∑Êù•', 'adj. ÂæóÂæà'],
                patternWords: 'Ëµ∑Êù•, ÂæóÂæà'
            },
            {
                line: 11,
                speaker: 'Daniel',
                chinese: 'ÊàëÂ•Ω‰πÖÊ≤°ÂêÉËøáËøô‰πàÈöæÂêÉÁöÑÈ•≠‰∫ÜÔºÅ',
                pinyin: 'W«í h«éoji«î m√©i chƒ´gu√≤ zh√®me n√°nchƒ´ de f√†n le!',
                english: "I haven't eaten food this bad in a long time!",
                patterns: ['Time Ê≤° V ‰∫Ü'],
                patternWords: 'Â•Ω‰πÖÊ≤°/‰∫Ü'
            },
            {
                line: 12,
                speaker: 'Jeremy',
                chinese: 'ÂÖ∂ÂÆû‰Ω†ÁöÑÈ•≠Âπ∂‰∏çÈöæÂêÉÔºå*spits*ÔºåÊòØË∂ÖÁ∫ßÈöæÂêÉÔºÅ',
                pinyin: 'Q√≠sh√≠ n«ê de f√†n b√¨ng b√π n√°nchƒ´, *spits*, sh√¨ chƒÅoj√≠ n√°nchƒ´!',
                english: "Actually, your food isn't bad... *spits* ...it's SUPER bad!",
                patterns: ['ÂÖ∂ÂÆû...Âπ∂‰∏ç...'],
                patternWords: 'ÂÖ∂ÂÆû/Âπ∂‰∏ç'
            },
            {
                line: 13,
                speaker: 'Daniel',
                chinese: '‰Ω†ÂÅöÁöÑËèúËøûÁãóÈÉΩ‰∏ç‰ºöÂêÉ„ÄÇ',
                pinyin: 'N«ê zu√≤ de c√†i li√°n g«íu d≈çu b√π hu√¨ chƒ´.',
                english: "Even dogs wouldn't eat the food you make.",
                patterns: ['Ëøû...ÈÉΩ...'],
                patternWords: 'Ëøû/ÈÉΩ'
            },
            {
                line: 14,
                speaker: 'Sam',
                chinese: '‰ª•ÂêéÊàëÊâç‰∏çÊÉ≥Áªô‰Ω†‰ª¨ÂÅöÈ•≠„ÄÇ',
                pinyin: 'Y«êh√≤u w«í c√°i b√π xi«éng gƒõi n«êmen zu√≤f√†n.',
                english: "From now on, I definitely won't cook for you guys.",
                patterns: ['Êâç'],
                patternWords: 'Êâç'
            },
            {
                line: 15,
                speaker: 'Jeremy',
                chinese: 'ÈÇ£ÊúÄÂ•Ω‰π∞Â§ñÂçñÂêß„ÄÇ',
                pinyin: 'N√† zu√¨h«éo m«éi w√†im√†i ba.',
                english: "Then we'd better just get takeout.",
                patterns: ['ÊúÄÂ•Ω + V'],
                patternWords: 'ÊúÄÂ•Ω'
            },
            {
                line: 16,
                speaker: 'Daniel',
                chinese: 'Â§ñÂçñ‰πüÂ•ΩÔºåÁãóÂ±é‰πüÂ•ΩÔºåÈÉΩÊØî‰Ω†ÂÅöÁöÑËèúÂ•ΩÂêÉÂ§ö‰∫Ü„ÄÇ',
                pinyin: 'W√†im√†i yƒõ h«éo, g«íush«ê yƒõ h«éo, d≈çu b«ê n«ê zu√≤ de c√†i h«éochƒ´ du≈ç le.',
                english: "Takeout is fine, dog shit is fine too, anything is better than the food you make.",
                patterns: ['A ‰πüÂ•ΩÔºåB ‰πüÂ•ΩÔºåÈÉΩ...', 'A ÊØî B adj. Â§ö‰∫Ü'],
                patternWords: '‰πüÂ•Ω/‰πüÂ•Ω/ÈÉΩ, ÊØî/Â§ö‰∫Ü'
            },
            {
                line: 17,
                speaker: 'Jeremy',
                chinese: 'Â§ñÂçñË¥µÊòØË¥µÔºåÂèØÊòØËøòÊòØÊØî‰Ω†ÁöÑËèúÂ•ΩÂêÉÔºÅ',
                pinyin: 'W√†im√†i gu√¨ sh√¨ gu√¨, kƒõsh√¨ h√°ishi b«ê n«ê de c√†i h«éochƒ´!',
                english: "Takeout is expensive, sure, but it's still tastier than your cooking!",
                patterns: ['adj. ÊòØ adj.ÔºåÂèØÊòØ...'],
                patternWords: 'Ë¥µÊòØË¥µ/ÂèØÊòØ'
            }
        ];

        // Filter out stage directions for practice
        const practiceDialogue = dialogue.filter(d => !d.isStageDirection);
        const jeremyLines = practiceDialogue.filter(d => d.speaker === 'Jeremy');
        const patternLines = practiceDialogue.filter(d => d.patterns.length > 0);

        let currentMode = 'english-to-chinese';
        let currentIndex = 0;
        let currentData = practiceDialogue;
        let answerShown = false;

        // Speaker colors
        const speakerColors = {
            'Sam': 'text-blue-600',
            'Daniel': 'text-green-600',
            'Jeremy': 'text-purple-600'
        };

        // Mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active', 'bg-blue-500', 'text-white', 'border-blue-500'));
                btn.classList.add('active', 'bg-blue-500', 'text-white', 'border-blue-500');
                currentMode = btn.dataset.mode;
                currentIndex = 0;
                answerShown = false;

                // Update current data based on mode
                if (currentMode === 'role-jeremy') {
                    currentData = jeremyLines;
                } else if (currentMode === 'fill-blank') {
                    currentData = patternLines;
                } else {
                    currentData = practiceDialogue;
                }

                updateDisplay();
            });
        });

        // Initialize with first mode selected
        document.querySelector('.mode-btn[data-mode="english-to-chinese"]').classList.add('active', 'bg-blue-500', 'text-white', 'border-blue-500');

        function updateDisplay() {
            const studyMode = document.getElementById('studyMode');
            const practiceMode = document.getElementById('practiceMode');
            const fillMode = document.getElementById('fillMode');

            studyMode.classList.add('hidden');
            practiceMode.classList.add('hidden');
            fillMode.classList.add('hidden');
            flowMode.classList.add('hidden');
            translateMode.classList.add('hidden');
            stopFlow(); // Stop flow if switching modes

            if (currentMode === 'study') {
                studyMode.classList.remove('hidden');
                renderStudyMode();
            } else if (currentMode === 'fill-blank') {
                fillMode.classList.remove('hidden');
                renderFillMode();
            } else if (currentMode === 'flow') {
                flowMode.classList.remove('hidden');
                renderFlowMode();
            } else if (currentMode === 'translate') {
                translateMode.classList.remove('hidden');
                renderTranslateMode();
            } else {
                practiceMode.classList.remove('hidden');
                renderPracticeMode();
            }
        }

        // ========== Translate Mode ==========
        const translateMode = document.getElementById('translateMode');

        function renderTranslateMode() {
            const item = currentData[currentIndex];
            const colorClass = speakerColors[item.speaker] || 'text-gray-800';

            document.getElementById('translateLineNumber').textContent = `Line ${item.line}`;
            document.getElementById('translateSpeaker').innerHTML = `<span class="${colorClass}">${item.speaker}</span>`;
            document.getElementById('translatePrompt').textContent = item.chinese;
            document.getElementById('translateInput').value = '';
            document.getElementById('translateFeedback').classList.add('hidden');
            document.getElementById('translateProgress').textContent = `${currentIndex + 1} / ${currentData.length}`;

            // Auto-play audio
            setTimeout(() => speakChinese(item.chinese), 300);
        }

        document.getElementById('translatePrompt').addEventListener('click', () => {
            const item = currentData[currentIndex];
            speakChinese(item.chinese);
        });

        document.getElementById('translateAudioBtn').addEventListener('click', () => {
            const item = currentData[currentIndex];
            speakChinese(item.chinese);
        });

        document.getElementById('translatePrevBtn').addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateDisplay();
            }
        });

        document.getElementById('translateNextBtn').addEventListener('click', () => {
            if (currentIndex < currentData.length - 1) {
                currentIndex++;
                updateDisplay();
            }
        });

        document.getElementById('translateCheckBtn').addEventListener('click', checkTranslation);
        document.getElementById('translateInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                checkTranslation();
            }
        });

        async function checkTranslation() {
            const apiKey = window.getGroqApiKey ? window.getGroqApiKey() : '';
            if (!apiKey) {
                alert('Please set your Groq API key first.\n\nPress Ctrl+K and search for "Set Groq API Key"');
                return;
            }

            const item = currentData[currentIndex];
            const userTranslation = document.getElementById('translateInput').value.trim();

            if (!userTranslation) {
                alert('Please enter a translation first.');
                return;
            }

            const checkBtn = document.getElementById('translateCheckBtn');
            checkBtn.textContent = 'Checking...';
            checkBtn.disabled = true;

            try {
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'moonshotai/kimi-k2-instruct-0905',
                        messages: [
                            {
                                role: 'system',
                                content: `You are a Chinese language teacher evaluating English translations of Chinese sentences.
Be encouraging but accurate. Rate translations as: CORRECT (captures meaning well), PARTIAL (mostly right but missing nuance), or INCORRECT.
Keep explanations brief (1-2 sentences). Focus on meaning, not exact wording.`
                            },
                            {
                                role: 'user',
                                content: `Chinese: ${item.chinese}
Reference translation: ${item.english}
Student's translation: ${userTranslation}

Evaluate the student's translation. Is it correct? Explain briefly.`
                            }
                        ],
                        max_tokens: 150,
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const result = await response.json();
                const feedback = result.choices[0]?.message?.content || 'No feedback received.';

                // Parse result
                const feedbackEl = document.getElementById('translateFeedback');
                const resultEl = document.getElementById('translateResult');
                const explanationEl = document.getElementById('translateExplanation');
                const referenceEl = document.getElementById('translateReference');

                const isCorrect = /\bCORRECT\b/i.test(feedback) && !/\bINCORRECT\b/i.test(feedback);
                const isPartial = /\bPARTIAL\b/i.test(feedback);

                if (isCorrect) {
                    feedbackEl.className = 'p-4 rounded-lg mb-4 bg-green-50 border border-green-200';
                    resultEl.innerHTML = '<span class="text-green-600 font-bold text-lg">‚úì Correct!</span>';
                } else if (isPartial) {
                    feedbackEl.className = 'p-4 rounded-lg mb-4 bg-yellow-50 border border-yellow-200';
                    resultEl.innerHTML = '<span class="text-yellow-600 font-bold text-lg">~ Partial</span>';
                } else {
                    feedbackEl.className = 'p-4 rounded-lg mb-4 bg-red-50 border border-red-200';
                    resultEl.innerHTML = '<span class="text-red-600 font-bold text-lg">‚úó Needs work</span>';
                }

                explanationEl.textContent = feedback.replace(/\b(CORRECT|PARTIAL|INCORRECT)\b:?\s*/gi, '').trim();
                referenceEl.innerHTML = `<strong>Reference:</strong> ${item.english}`;
                feedbackEl.classList.remove('hidden');

            } catch (err) {
                console.error('Translation check error:', err);
                alert('Error checking translation: ' + err.message);
            } finally {
                checkBtn.textContent = 'Check Translation';
                checkBtn.disabled = false;
            }
        }

        // ========== Flow Mode ==========
        const flowMode = document.getElementById('flowMode');
        let flowRunning = false;
        let flowIndex = 0;
        let flowHits = 0;
        let flowMisses = 0;
        let flowTotal = 0;
        let flowWaitingForSpace = false;
        let flowTimeout = null;
        let flowTimerInterval = null;
        let flowTimeLeft = 0;
        const FLOW_WAIT_TIME = 2000; // 2 seconds to press space

        function renderFlowMode() {
            document.getElementById('flowStartBtn').textContent = '‚ñ∂ Start Flow';
            document.getElementById('flowDisplay').classList.add('hidden');
            document.getElementById('flowScore').classList.add('hidden');
            flowRunning = false;
        }

        function stopFlow() {
            flowRunning = false;
            flowWaitingForSpace = false;
            if (flowTimeout) clearTimeout(flowTimeout);
            if (flowTimerInterval) clearInterval(flowTimerInterval);
        }

        document.getElementById('flowStartBtn').addEventListener('click', () => {
            if (flowRunning) {
                stopFlow();
                renderFlowMode();
            } else {
                startFlow();
            }
        });

        function startFlow() {
            flowRunning = true;
            flowIndex = 0;
            flowHits = 0;
            flowMisses = 0;
            flowTotal = jeremyLines.length;

            document.getElementById('flowStartBtn').textContent = '‚èπ Stop';
            document.getElementById('flowDisplay').classList.remove('hidden');
            document.getElementById('flowScore').classList.remove('hidden');
            document.getElementById('flowHits').textContent = '0';
            document.getElementById('flowTotal').textContent = flowTotal;
            document.getElementById('flowMisses').textContent = '0';

            playFlowLine(0);
        }

        function playFlowLine(dialogueIndex) {
            if (!flowRunning || dialogueIndex >= dialogue.length) {
                // End of dialogue
                flowRunning = false;
                document.getElementById('flowStatus').innerHTML = `<span class="text-green-600">Done! ${flowHits}/${flowTotal} correct</span>`;
                document.getElementById('flowTimer').classList.add('hidden');
                document.getElementById('flowStartBtn').textContent = '‚ñ∂ Restart';
                return;
            }

            const item = dialogue[dialogueIndex];

            // Skip stage directions
            if (item.isStageDirection) {
                setTimeout(() => playFlowLine(dialogueIndex + 1), 500);
                return;
            }

            const colorClass = speakerColors[item.speaker] || 'text-gray-800';
            document.getElementById('flowSpeaker').innerHTML = `<span class="${colorClass}">${item.speaker}</span>`;
            document.getElementById('flowLine').textContent = item.chinese;
            document.getElementById('flowStatus').textContent = '';
            document.getElementById('flowTimer').classList.add('hidden');

            if (item.speaker === 'Jeremy') {
                // It's Jeremy's turn - wait for space
                flowWaitingForSpace = true;
                document.getElementById('flowTimer').classList.remove('hidden');
                document.getElementById('flowTimerBar').style.width = '100%';
                flowTimeLeft = FLOW_WAIT_TIME;

                // Animate timer bar
                flowTimerInterval = setInterval(() => {
                    flowTimeLeft -= 50;
                    const pct = Math.max(0, (flowTimeLeft / FLOW_WAIT_TIME) * 100);
                    document.getElementById('flowTimerBar').style.width = pct + '%';
                }, 50);

                flowTimeout = setTimeout(() => {
                    // Missed!
                    if (flowWaitingForSpace) {
                        flowWaitingForSpace = false;
                        clearInterval(flowTimerInterval);
                        flowMisses++;
                        document.getElementById('flowMisses').textContent = flowMisses;
                        document.getElementById('flowStatus').innerHTML = '<span class="text-red-600">‚ùå Missed! That was your line!</span>';
                        document.getElementById('flowTimer').classList.add('hidden');

                        // Play the line anyway, then continue
                        speakChinese(item.chinese);
                        setTimeout(() => playFlowLine(dialogueIndex + 1), 3000);
                    }
                }, FLOW_WAIT_TIME);
            } else {
                // Other speaker - play audio and continue
                speakChinese(item.chinese);
                // Estimate speech duration (rough: 300ms per character)
                const duration = Math.max(1500, item.chinese.length * 300);
                setTimeout(() => playFlowLine(dialogueIndex + 1), duration);
            }
        }

        function handleFlowSpace() {
            if (!flowRunning || !flowWaitingForSpace) return;

            flowWaitingForSpace = false;
            clearTimeout(flowTimeout);
            clearInterval(flowTimerInterval);

            flowHits++;
            document.getElementById('flowHits').textContent = flowHits;
            document.getElementById('flowStatus').innerHTML = '<span class="text-green-600">‚úì Correct! Your turn!</span>';
            document.getElementById('flowTimer').classList.add('hidden');

            // Find current Jeremy line index
            const currentItem = dialogue[flowIndex];
            const jeremyIdx = dialogue.findIndex((d, i) => i >= flowIndex && d.speaker === 'Jeremy');
            if (jeremyIdx >= 0) {
                // Play Jeremy's line, then continue
                speakChinese(dialogue[jeremyIdx].chinese);
                setTimeout(() => playFlowLine(jeremyIdx + 1), 3000);
            }
        }

        // Update flowIndex when playing
        const originalPlayFlowLine = playFlowLine;
        playFlowLine = function(idx) {
            flowIndex = idx;
            originalPlayFlowLine(idx);
        };

        function renderStudyMode() {
            const list = document.getElementById('dialogueList');
            list.innerHTML = dialogue.map((d, idx) => {
                if (d.isStageDirection) {
                    return `<div class="text-center text-gray-400 italic py-2">${d.chinese}</div>`;
                }
                const colorClass = speakerColors[d.speaker] || 'text-gray-800';
                const patternBadges = d.patterns.length > 0
                    ? `<div class="text-xs text-purple-500 mt-1">${d.patterns.join(' ¬∑ ')}</div>`
                    : '';
                return `
                    <div class="p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition">
                        <div class="flex items-start gap-3">
                            <span class="font-bold ${colorClass} w-16 flex-shrink-0">${d.line}. ${d.speaker}</span>
                            <div class="flex-1">
                                <div class="text-xl mb-1">${d.chinese}</div>
                                <div class="text-gray-500 text-sm">${d.pinyin}</div>
                                <div class="text-gray-600 text-sm mt-1">${d.english}</div>
                                ${patternBadges}
                                <div id="study-transcription-${idx}" class="hidden mt-2 p-2 bg-blue-50 rounded text-sm"></div>
                            </div>
                            <div class="flex gap-1 flex-shrink-0">
                                <button class="study-play-btn bg-cyan-500 hover:bg-cyan-600 text-white px-3 py-1 rounded text-sm" data-idx="${idx}">üîä</button>
                                <button class="study-record-btn bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm" data-idx="${idx}">üé§</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Attach event listeners
            list.querySelectorAll('.study-play-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.idx);
                    speakChinese(dialogue[idx].chinese);
                });
            });

            list.querySelectorAll('.study-record-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.idx);
                    toggleStudyRecording(btn, idx);
                });
            });
        }

        // Study mode recording state
        let studyRecordingBtn = null;
        let studyRecordingIdx = null;

        async function toggleStudyRecording(btn, idx) {
            // If already recording this line, stop it
            if (studyRecordingBtn === btn && isRecording) {
                stopStudyRecording();
                return;
            }

            // If recording a different line, stop that first
            if (isRecording && studyRecordingBtn) {
                stopStudyRecording();
            }

            // Start new recording
            const apiKey = window.getGroqApiKey ? window.getGroqApiKey() : '';
            if (!apiKey) {
                alert('Please set your Groq API key first.\n\nPress Ctrl+K and search for "Set Groq API Key"');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await transcribeStudyAudio(audioBlob, idx);
                };

                mediaRecorder.start();
                isRecording = true;
                studyRecordingBtn = btn;
                studyRecordingIdx = idx;
                btn.textContent = '‚èπ';
                btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                btn.classList.add('bg-orange-500', 'hover:bg-orange-600', 'animate-pulse');

                // Hide previous transcription for this line
                document.getElementById(`study-transcription-${idx}`).classList.add('hidden');
            } catch (err) {
                console.error('Recording error:', err);
                alert('Could not access microphone.');
            }
        }

        function stopStudyRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                if (studyRecordingBtn) {
                    studyRecordingBtn.textContent = 'üé§';
                    studyRecordingBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'animate-pulse');
                    studyRecordingBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                }
                studyRecordingBtn = null;
            }
        }

        async function transcribeStudyAudio(audioBlob, idx) {
            const apiKey = window.getGroqApiKey();
            const item = dialogue[idx];
            const btn = document.querySelector(`.study-record-btn[data-idx="${idx}"]`);
            const transcriptionEl = document.getElementById(`study-transcription-${idx}`);

            if (btn) {
                btn.textContent = '‚è≥';
                btn.disabled = true;
            }

            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-large-v3-turbo');
                formData.append('language', 'zh');
                formData.append('response_format', 'json');

                const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}` },
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const result = await response.json();
                const transcription = result.text || '';

                // Compare with expected
                const expected = item.chinese.replace(/\*[^*]+\*/g, '').replace(/[Ôºå„ÄÇÔºÅÔºü„ÄÅ]/g, '');
                const actual = transcription.replace(/[Ôºå„ÄÇÔºÅÔºü„ÄÅ]/g, '');

                let feedback;
                if (actual === expected || transcription.includes(expected) || expected.includes(actual)) {
                    feedback = `<span class="text-green-600 font-semibold">‚úì "${transcription}"</span>`;
                } else {
                    const diff = compareStrings(expected, actual);
                    feedback = `You said: ${diff}`;
                }

                transcriptionEl.innerHTML = feedback;
                transcriptionEl.classList.remove('hidden');

            } catch (err) {
                transcriptionEl.innerHTML = `<span class="text-red-600">Error: ${err.message}</span>`;
                transcriptionEl.classList.remove('hidden');
            } finally {
                if (btn) {
                    btn.textContent = 'üé§';
                    btn.disabled = false;
                }
            }
        }

        function renderPracticeMode() {
            const item = currentData[currentIndex];
            const colorClass = speakerColors[item.speaker] || 'text-gray-800';

            // Show context (preceding lines) in role-jeremy mode
            const contextDisplay = document.getElementById('contextDisplay');
            const contextLines = document.getElementById('contextLines');

            if (currentMode === 'role-jeremy') {
                // Find this item's position in the full dialogue
                const dialogueIdx = dialogue.findIndex(d => d.line === item.line);
                if (dialogueIdx > 0) {
                    // Get up to 3 preceding lines
                    const startIdx = Math.max(0, dialogueIdx - 3);
                    const precedingLines = dialogue.slice(startIdx, dialogueIdx).filter(d => !d.isStageDirection);

                    if (precedingLines.length > 0) {
                        contextLines.innerHTML = precedingLines.map(d => {
                            const color = speakerColors[d.speaker] || 'text-gray-800';
                            return `<div><span class="font-semibold ${color}">${d.speaker}:</span> ${d.chinese}</div>`;
                        }).join('');
                        contextDisplay.classList.remove('hidden');
                    } else {
                        contextDisplay.classList.add('hidden');
                    }
                } else {
                    contextDisplay.classList.add('hidden');
                }
            } else {
                contextDisplay.classList.add('hidden');
            }

            document.getElementById('lineNumber').textContent = `Line ${item.line} of ${dialogue.length - 1}`;
            document.getElementById('speaker').innerHTML = `<span class="${colorClass}">${item.speaker}</span>`;
            document.getElementById('questionDisplay').textContent = item.english;

            if (item.patterns.length > 0) {
                document.getElementById('patternHint').textContent = `Patterns: ${item.patterns.join(', ')}`;
            } else {
                document.getElementById('patternHint').textContent = '';
            }

            document.getElementById('answerChinese').textContent = item.chinese;
            document.getElementById('answerPinyin').textContent = item.pinyin;
            document.getElementById('answerDisplay').classList.add('hidden');
            document.getElementById('transcriptionDisplay').classList.add('hidden');
            answerShown = false;

            document.getElementById('progress').textContent = `${currentIndex + 1} / ${currentData.length}`;
        }

        function renderFillMode() {
            const item = currentData[currentIndex];
            const colorClass = speakerColors[item.speaker] || 'text-gray-800';

            // Create blanked version of Chinese text
            let blanked = item.chinese;
            const words = item.patternWords.split(', ');
            words.forEach(w => {
                const parts = w.split('/');
                parts.forEach(p => {
                    blanked = blanked.replace(p, '___');
                });
            });

            document.getElementById('fillLineNumber').textContent = `Line ${item.line}`;
            document.getElementById('fillSpeaker').innerHTML = `<span class="${colorClass}">${item.speaker}</span>`;
            document.getElementById('fillQuestion').innerHTML = blanked;
            document.getElementById('fillEnglish').textContent = item.english;
            document.getElementById('fillInput').value = '';
            document.getElementById('fillFeedback').textContent = '';
            document.getElementById('fillProgress').textContent = `${currentIndex + 1} / ${currentData.length}`;
        }

        // Navigation
        document.getElementById('prevBtn').addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateDisplay();
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (currentIndex < currentData.length - 1) {
                currentIndex++;
                updateDisplay();
            }
        });

        document.getElementById('fillPrevBtn').addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateDisplay();
            }
        });

        document.getElementById('fillNextBtn').addEventListener('click', () => {
            if (currentIndex < currentData.length - 1) {
                currentIndex++;
                updateDisplay();
            }
        });

        // Show answer
        document.getElementById('showAnswerBtn').addEventListener('click', () => {
            const display = document.getElementById('answerDisplay');
            if (answerShown) {
                display.classList.add('hidden');
                answerShown = false;
            } else {
                display.classList.remove('hidden');
                answerShown = true;
            }
        });

        // Audio playback
        function speakChinese(text) {
            // Use Edge TTS if available (natural sounding), fallback to browser TTS
            if (window.edgeTTS) {
                window.edgeTTS(text);
            } else {
                const cleanText = text.replace(/\*[^*]+\*/g, '').replace(/„Äà[^„Äâ]+„Äâ/g, '');
                const utterance = new SpeechSynthesisUtterance(cleanText);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.85;
                speechSynthesis.cancel();
                speechSynthesis.speak(utterance);
            }
        }

        document.getElementById('playAudioBtn').addEventListener('click', () => {
            const item = currentData[currentIndex];
            speakChinese(item.chinese);
        });

        document.getElementById('fillAudioBtn').addEventListener('click', () => {
            const item = currentData[currentIndex];
            speakChinese(item.chinese);
        });

        // Fill mode check
        document.getElementById('fillCheckBtn').addEventListener('click', checkFillAnswer);
        document.getElementById('fillInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') checkFillAnswer();
        });

        function checkFillAnswer() {
            const item = currentData[currentIndex];
            const input = document.getElementById('fillInput').value.trim();
            const feedback = document.getElementById('fillFeedback');

            // Get all pattern words
            const expectedWords = item.patternWords.split(', ').flatMap(w => w.split('/'));
            const inputWords = input.replace(/[,Ôºå/]/g, ' ').split(/\s+/).filter(w => w);

            // Check if input contains the key pattern words
            const allFound = expectedWords.every(exp =>
                inputWords.some(inp => inp === exp || exp.includes(inp) || inp.includes(exp))
            );

            if (allFound || input === item.patternWords.replace(/[,/]/g, ' ')) {
                feedback.innerHTML = `<span class="text-green-600">‚úì Correct!</span> <span class="text-gray-600">${item.patternWords}</span>`;
            } else {
                feedback.innerHTML = `<span class="text-red-600">‚úó</span> Expected: <span class="text-gray-800">${item.patternWords}</span>`;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Allow typing in inputs/textareas, except for specific shortcuts
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // In translate mode, space after feedback advances to next
                if (currentMode === 'translate' && e.key === ' ') {
                    const feedbackVisible = !document.getElementById('translateFeedback').classList.contains('hidden');
                    if (feedbackVisible) {
                        e.preventDefault();
                        if (currentIndex < currentData.length - 1) {
                            currentIndex++;
                            updateDisplay();
                        }
                    }
                }
                return;
            }

            // Flow mode space handling
            if (currentMode === 'flow' && e.key === ' ') {
                e.preventDefault();
                handleFlowSpace();
                return;
            }

            // Translate mode space after feedback
            if (currentMode === 'translate' && e.key === ' ') {
                const feedbackVisible = !document.getElementById('translateFeedback').classList.contains('hidden');
                if (feedbackVisible) {
                    e.preventDefault();
                    if (currentIndex < currentData.length - 1) {
                        currentIndex++;
                        updateDisplay();
                    }
                }
                return;
            }

            if (e.key === 'ArrowLeft') {
                if (currentIndex > 0) {
                    currentIndex--;
                    updateDisplay();
                }
            } else if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                if (currentIndex < currentData.length - 1) {
                    currentIndex++;
                    updateDisplay();
                }
            } else if (e.key === 'Enter') {
                const item = currentData[currentIndex];
                speakChinese(item.chinese);
            } else if (e.key === 's') {
                document.getElementById('showAnswerBtn').click();
            }
        });

        // Initialize command palette
        if (typeof initCommandPalette === 'function') {
            initCommandPalette();
        }

        // Initial render
        updateDisplay();

        // ========== Recording & Transcription ==========
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        const recordBtn = document.getElementById('recordBtn');

        recordBtn.addEventListener('click', async () => {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        });

        async function startRecording() {
            const apiKey = window.getGroqApiKey ? window.getGroqApiKey() : '';
            if (!apiKey) {
                alert('Please set your Groq API key first.\n\nPress Ctrl+K and search for "Set Groq API Key"');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await transcribeAudio(audioBlob);
                };

                mediaRecorder.start();
                isRecording = true;
                recordBtn.textContent = '‚èπ Stop';
                recordBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                recordBtn.classList.add('bg-orange-500', 'hover:bg-orange-600', 'animate-pulse');

                // Hide previous transcription
                document.getElementById('transcriptionDisplay').classList.add('hidden');
            } catch (err) {
                console.error('Recording error:', err);
                alert('Could not access microphone. Please allow microphone access.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = 'üé§ Record';
                recordBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'animate-pulse');
                recordBtn.classList.add('bg-red-500', 'hover:bg-red-600');
            }
        }

        async function transcribeAudio(audioBlob) {
            const apiKey = window.getGroqApiKey();
            const item = currentData[currentIndex];

            recordBtn.textContent = '‚è≥ Transcribing...';
            recordBtn.disabled = true;

            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-large-v3-turbo');
                formData.append('language', 'zh');
                formData.append('response_format', 'json');

                const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API error: ${response.status} - ${errText}`);
                }

                const result = await response.json();
                const transcription = result.text || '';

                // Display transcription
                document.getElementById('transcriptionText').textContent = transcription;
                document.getElementById('transcriptionDisplay').classList.remove('hidden');

                // Compare with expected
                const expected = item.chinese.replace(/\*[^*]+\*/g, '').replace(/[Ôºå„ÄÇÔºÅÔºü„ÄÅ]/g, '');
                const actual = transcription.replace(/[Ôºå„ÄÇÔºÅÔºü„ÄÅ]/g, '');

                const feedbackEl = document.getElementById('transcriptionFeedback');
                if (actual === expected || transcription.includes(expected) || expected.includes(actual)) {
                    feedbackEl.innerHTML = '<span class="text-green-600 font-semibold">‚úì Great match!</span>';
                } else {
                    // Show character-by-character comparison
                    const diff = compareStrings(expected, actual);
                    feedbackEl.innerHTML = `<span class="text-gray-600">Expected: ${item.chinese}</span><br>${diff}`;
                }

            } catch (err) {
                console.error('Transcription error:', err);
                document.getElementById('transcriptionText').textContent = 'Error: ' + err.message;
                document.getElementById('transcriptionFeedback').textContent = '';
                document.getElementById('transcriptionDisplay').classList.remove('hidden');
            } finally {
                recordBtn.textContent = 'üé§ Record';
                recordBtn.disabled = false;
            }
        }

        function compareStrings(expected, actual) {
            let result = '';
            const maxLen = Math.max(expected.length, actual.length);
            for (let i = 0; i < actual.length; i++) {
                if (i < expected.length && actual[i] === expected[i]) {
                    result += `<span class="text-green-600">${actual[i]}</span>`;
                } else {
                    result += `<span class="text-red-600">${actual[i]}</span>`;
                }
            }
            return result;
        }

        // Keyboard shortcut for recording
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
                recordBtn.click();
            }
        });
    </script>
</body>
</html>
